// ---------------------------------------------------------------------------
//   mmmmmmm mmmmmm m    mmmmmmmm         mmmm    mm   mmmmm  mmmmm  mmmmmm
//      #    #       #  #    #           #"   "   ##   #    # #   "# #
//      #    #mmmmm   ##     #           "#mmm   #  #  #mmmm" #mmmm" #mmmmm
//      #    #       m""m    #               "#  #mm#  #    # #   "m #
//      #    #mmmmm m"  "m   #           "mmm#" #    # #mmmm" #    " #mmmmm
// ---------------------------------------------------------------------------
// 2024-12-21 version 1.00 by @pp19dd
//
//                        code + STL: https://github.com/pp19dd/textsabre
//               radial pixel editor: https://pp19dd.com/textsabre/editor.html
//
// ---------------------------------------------------------------------------
// in Arduino IDE: tools -> managed libraries -> search -> install
//      - required library: FastGPIO by Pololu version 2.2.0
//      - required library: APA102 by Pololu version 3.0.0
//
// common troubleshooting:
//      - tools->board->"Arduino Nano"
//      - tools->processor->"ATmega328P (Old Bootloader)"
//      - tools->port->choose the USB port that appears when plugged in
//      - might need CH340 driver from https://sparks.gogo.co.nz/ch340.html
//      - might need proper mini-USB data cable (USB to host cable)
// ---------------------------------------------------------------------------
#include <EEPROM.h>
#include <FastGPIO.h>
#define APA102_USE_FAST_GPIO
#include <APA102.h>
#include "timer.h"
#include "data.h"                          // generated by radial pixel editor

// ---------------------------------------------------------------------------
// debug options - comment out for normal operation
// ---------------------------------------------------------------------------
// #define SERIAL_CONSOLE      // outputs sensor values, program state changes
// #define BLUE_LINE           // displays a blue line on column = 0

// ---------------------------------------------------------------------------
// hardware setup
// ---------------------------------------------------------------------------
#define PIN_DATA        11                  // APA102C / SK9822 LED strip
#define PIN_CLOCK       12                  //    "          "
#define LED_COLUMNS    144
#define LED_COUNT       34
#define PIN_SENSOR      A6                  // hall effect sensor 49E
#define PIN_BUTTON_UP   4                   // push-button
#define PIN_BUTTON_DOWN 3                   // push-button
#define PIN_BUTTON_OK   2                   // push-button

// ---------------------------------------------------------------------------
// program config
// ---------------------------------------------------------------------------
// if "zero point" looks jittery, or image keeps losing its rotation
// alter this value to account for a noisy magnet / sensor transition
//     tested value for distant magnet: 5
//     tested value for   close magnet: 10
#define REPEAT_THRESHOLD    10

// assume we're touching menu buttons after not spinning for __ second(s)
#define SPIN_TIMEOUT        1 * 1000000

int intensity = 8;
int menu = 0;
bool delay_after_paint = false;
const int EEPROM_ADDR_MENU = 0;


// ---------------------------------------------------------------------------
// link to data.h - 8 images saved to program memory
// ---------------------------------------------------------------------------
typedef struct {
    const uint8_t *plane0;
    const uint8_t *plane1;
    const uint8_t *plane2;
} image_t;

extern const uint8_t IMAGE_0_0[] PROGMEM;
extern const uint8_t IMAGE_0_1[] PROGMEM;
extern const uint8_t IMAGE_0_2[] PROGMEM;

extern const uint8_t IMAGE_1_0[] PROGMEM;
extern const uint8_t IMAGE_1_1[] PROGMEM;
extern const uint8_t IMAGE_1_2[] PROGMEM;

extern const uint8_t IMAGE_2_0[] PROGMEM;
extern const uint8_t IMAGE_2_1[] PROGMEM;
extern const uint8_t IMAGE_2_2[] PROGMEM;

extern const uint8_t IMAGE_3_0[] PROGMEM;
extern const uint8_t IMAGE_3_1[] PROGMEM;
extern const uint8_t IMAGE_3_2[] PROGMEM;

extern const uint8_t IMAGE_4_0[] PROGMEM;
extern const uint8_t IMAGE_4_1[] PROGMEM;
extern const uint8_t IMAGE_4_2[] PROGMEM;

extern const uint8_t IMAGE_5_0[] PROGMEM;
extern const uint8_t IMAGE_5_1[] PROGMEM;
extern const uint8_t IMAGE_5_2[] PROGMEM;

extern const uint8_t IMAGE_6_0[] PROGMEM;
extern const uint8_t IMAGE_6_1[] PROGMEM;
extern const uint8_t IMAGE_6_2[] PROGMEM;

extern const uint8_t IMAGE_7_0[] PROGMEM;
extern const uint8_t IMAGE_7_1[] PROGMEM;
extern const uint8_t IMAGE_7_2[] PROGMEM;

const image_t images[] PROGMEM = {
    { IMAGE_0_0, IMAGE_0_1, IMAGE_0_2 },
    { IMAGE_1_0, IMAGE_1_1, IMAGE_1_2 },
    { IMAGE_2_0, IMAGE_2_1, IMAGE_2_2 },
    { IMAGE_3_0, IMAGE_3_1, IMAGE_3_2 },
    { IMAGE_4_0, IMAGE_4_1, IMAGE_4_2 },
    { IMAGE_5_0, IMAGE_5_1, IMAGE_5_2 },
    { IMAGE_6_0, IMAGE_6_1, IMAGE_6_2 },
    { IMAGE_7_0, IMAGE_7_1, IMAGE_7_2 }
};
const uint8_t image_count = ( sizeof( images ) / sizeof( images[0] ) );

uint8_t palette[8][3];

const uint8_t base_palette[8][3] = {
    { 0,   0,   0   },   // 0: off
    { 255, 0,   0   },   // 1: red
    { 0,   255, 0   },   // 2: green
    { 0,   0,   255 },   // 3: blue
    { 255, 215, 0   },   // 4: gold
    { 255, 255, 255 },   // 5: white
    { 255, 140, 0   },   // 6: orange
    { 173, 216, 230 }    // 7: light blue
};

// ---------------------------------------------------------------------------
// program vars
// ---------------------------------------------------------------------------
int i;
int j;

uint8_t time_cursor = 0;

unsigned long last_rotation = 0;
unsigned long circle_time = 0;
unsigned long time_slice = 0;
unsigned long now = 0;
unsigned long last_toggle_ms = 0;

const uint8_t dataPin = PIN_DATA;
const uint8_t clockPin = PIN_CLOCK;
APA102<dataPin, clockPin> ledStrip;

rgb_color colors[LED_COUNT];

// ---------------------------------------------------------------------------
// program states and timers
// ---------------------------------------------------------------------------
enum ModeType
{
    M_SPIN,
    M_MENU
};

struct modeData {
    ModeType current_mode = M_MENU;
    ModeType prev_mode = M_MENU;
};

struct modeData program;

Timer timerBlink(250);
#ifdef SERIAL_CONSOLE
Timer timerSensor(1000);
#endif

#ifdef BLUE_LINE
unsigned long turnoff_time = 0;
#endif

// ---------------------------------------------------------------------------
// rising / falling edge detection vars for hall effect sensor 49E
// ---------------------------------------------------------------------------
struct sensorData {
    int value;
    int prev;
};

sensorData sensor;

enum EdgeType
{
    E_RISING,
    E_FALLING,
    E_FLAT
};

EdgeType current_edge = E_FLAT;
EdgeType prev_edge = E_FLAT;

int count_rising = 0;
int count_falling = 0;

// ---------------------------------------------------------------------------
//     mmmmm   mmmm  m    m mmmmmmm mmmmm  mm   m mmmmmm  mmmm
//     #   "# m"  "m #    #    #      #    #"m  # #      #"   "
//     #mmmm" #    # #    #    #      #    # #m # #mmmmm "#mmm
//     #   "m #    # #    #    #      #    #  # # #          "#
//     #    "  #mm#  "mmmm"    #    mm#mm  #   ## #mmmmm "mmm#"
// ---------------------------------------------------------------------------

// helper for setting LED pixel
void paint(int index, uint8_t r, uint8_t g, uint8_t b) {
    colors[index].red = r;
    colors[index].green = g;
    colors[index].blue = b;
}

// for changing pixel intensity value
void update_palette() {
    uint16_t scale = (uint16_t) intensity * 255 / 8;

    for( int c = 0; c < 8; c++ ) {
        for( int ch = 0; ch < 3; ch++ ) {
            palette[c][ch] = (uint8_t)( (uint16_t) base_palette[c][ch] * scale / 255 );
        }
    }
}

// draws an entire 4-byte column worth of pixels
void drawColumn(int index, uint8_t image_index) {
    int mirrored_col = (LED_COLUMNS - 1) - index;

    if( mirrored_col < 0 || mirrored_col >= LED_COLUMNS ) {
        return;
    }

    if( image_count == 0 ) {
        return;
    }

    image_index %= image_count;

    // fetch the three plane pointers from PROGMEM
    const image_t *img = &images[image_index];
    const uint8_t *plane0 = (const uint8_t *) pgm_read_ptr( &img->plane0 );
    const uint8_t *plane1 = (const uint8_t *) pgm_read_ptr( &img->plane1 );
    const uint8_t *plane2 = (const uint8_t *) pgm_read_ptr( &img->plane2 );

    int byte_offset = mirrored_col * 4;

    for( int b = 0; b < 4; b++ ) {
        uint16_t o = byte_offset + b;

        // read one byte from each of the three planes (through the selected image)
        uint8_t d0 = pgm_read_byte( &plane0[o] );
        uint8_t d1 = pgm_read_byte( &plane1[o] );
        uint8_t d2 = pgm_read_byte( &plane2[o] );

        // speed optimization: if all planes are empty for these 8 pixels, skip them
        if( (d0 | d1 | d2) == 0 ) {
            continue;
        }

        for( int i = 0; i < 8; i++ ) {
            uint8_t colorIndex =
                ( (uint8_t) bitRead(d2, i) << 2 ) |
                ( (uint8_t) bitRead(d1, i) << 1 ) |
                ( (uint8_t) bitRead(d0, i) );

            if( colorIndex > 0 ) {
                paint(
                    1 + (b * 8) + i,
                    palette[colorIndex][0],
                    palette[colorIndex][1],
                    palette[colorIndex][2]
                );
            }
        }
    }
}

// ---------------------------------------------------------------------------
//      mmmm  mmmmmm mmmmmmm m    m mmmmm
//     #"   " #         #    #    # #   "#
//     "#mmm  #mmmmm    #    #    # #mmm#"
//         "# #         #    #    # #
//     "mmm#" #mmmmm    #    "mmmm" #
// ---------------------------------------------------------------------------

void setup() {

    // buttons: no resistors needed for INPUT_PULLUP
    pinMode( PIN_BUTTON_UP,   INPUT_PULLUP );
    pinMode( PIN_BUTTON_DOWN, INPUT_PULLUP );
    pinMode( PIN_BUTTON_OK,   INPUT_PULLUP );

    // hall-effect sensor 49E
    pinMode( PIN_SENSOR, INPUT );

    update_palette();

    // last selected image slot
    menu = EEPROM.read(EEPROM_ADDR_MENU);
    
    // could be random before first burn-in
    if( menu < 0 ) menu = 0;
    if( menu > 7) menu = 7;

    // reset timers
    timerBlink.Reset();

    #ifdef SERIAL_CONSOLE
    Serial.begin(115200);
    Serial.println("setup()" );
    timerSensor.Reset();
    #endif
}


// ---------------------------------------------------------------------------
//     m       mmmm   mmmm  mmmmm
//     #      m"  "m m"  "m #   "#
//     #      #    # #    # #mmm#"
//     #      #    # #    # #
//     #mmmmm  #mm#   #mm#  #
// ---------------------------------------------------------------------------

void loop() {

    #ifdef SERIAL_CONSOLE
    timerSensor.doTick();
    #endif

    timerBlink.doTick();

    // rising / falling edge detection
    prev_edge = current_edge;
    sensor.prev = sensor.value;
    sensor.value = analogRead(PIN_SENSOR);

    if( sensor.value > sensor.prev ) {
        count_falling = 0;
        count_rising++;
        if( count_rising > REPEAT_THRESHOLD ) {
            current_edge = E_RISING;
        }
    }

    if( sensor.value < sensor.prev ) {
        count_rising = 0;
        count_falling++;

        if( count_falling > REPEAT_THRESHOLD ) {
            current_edge = E_FALLING;
        }
    }

    now = micros() - last_rotation;
    time_cursor = now / time_slice;
    
    // ROTATION DETECTED: single event
    // circle_time: how long it took to do a circle
    //  time_slice: given LED_COLUMNS, how long a single column should take to display
    //         now: time since circle started
    // time_cursor: integer, index of current column

    if( current_edge == E_FALLING && prev_edge == E_RISING ) {
    
        #ifdef SERIAL_CONSOLE
        Serial.println("changing edge detected");
        #endif


        circle_time = micros() - last_rotation;
        time_slice = (circle_time / LED_COLUMNS);

        #ifdef BLUE_LINE
        // was 36 in millis()
        turnoff_time = micros() + (circle_time / 360 );
        #endif

        //    counter++;
        //    if( counter > LED_COUNT ) counter = 0;

        last_rotation = micros();
    }

    // if we haven't spun this in under a second
    // that means we're probably in menu mode
    if( now > SPIN_TIMEOUT ) {
        program.current_mode = M_MENU;
    } else {
        program.current_mode = M_SPIN;
    }

    // process menu logic
    if( digitalRead(PIN_BUTTON_UP) == LOW ) {
        menu++;
        if( menu > 7) menu = 7;
        delay_after_paint = true;

        #ifdef SERIAL_CONSOLE
        Serial.println("PIN_BUTTON_UP");
        #endif
    }

    if( digitalRead(PIN_BUTTON_DOWN) == LOW ) {
        menu--;
        if( menu < 0 ) menu = 0;
        delay_after_paint = true;

        #ifdef SERIAL_CONSOLE
        Serial.println("PIN_BUTTON_DOWN");
        #endif
    }

    if( digitalRead(PIN_BUTTON_OK) == LOW ) {
        intensity = (8 - (menu));
        update_palette();
        delay_after_paint = true;

        #ifdef SERIAL_CONSOLE
        Serial.println("PIN_BUTTON_OK");
        #endif
    }

    // draw phase: first, erase all leds
    for( i = 0; i < LED_COUNT; i++ ) {
        paint(i, 0, 0, 0);
    }

    #ifdef SERIAL_CONSOLE
    if( program.current_mode != program.prev_mode ) {
        Serial.print("program mode changed: ");
        Serial.println( program.current_mode == M_MENU ? "M_MENU" : "M_SPIN");
    }
    #endif

    // program running modes
    if( program.current_mode == M_MENU ) {

        // mode 1: menu selection (up / down buttons)

        if( timerBlink.Blink ) {
            uint16_t scale = (uint16_t) (8 - (menu)) * 255 / 8;
            for( i = 0; i < 4; i++ ) {
                paint(
                    1 + (menu * 4) + i,
                    (uint8_t)( (uint16_t) base_palette[1][0] * scale / 255 ),
                    0,
                    0
                );
            }
        }

    } else if( program.current_mode == M_SPIN ) {

        // mode 2: spinning
        
        // mark inner and outer circles for safety
        paint(0, 32, 0, 0);
        paint(LED_COUNT-1, 32, 0, 0);
        drawColumn(time_cursor, menu);

    }

    program.prev_mode = program.current_mode;

    #ifdef BLUE_LINE
    // trigger blue line at column 0
    if( micros() < turnoff_time ) {
        paint(1, 0, 0, 128 );
        paint(2, 0, 0, 128 );
        paint(3, 0, 0, 128 );
        paint(4, 0, 0, 128 );
    }
    #endif

    //  Serial.println(sensor.value);
    ledStrip.write(colors, LED_COUNT, 1);

    if( delay_after_paint == true ) {
        delay(250);
        delay_after_paint = false;
        
        EEPROM.update(EEPROM_ADDR_MENU, menu);
    }

    #ifdef SERIAL_CONSOLE
    if( timerSensor.Run ) {
        Serial.print("sensor value: ");
        Serial.println(sensor.value);
    }
    #endif

}
